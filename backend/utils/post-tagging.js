/**
 * Post Tagging Utility
 *
 * Unified utility for generating AI tags for posts from both
 * text content and images. Respects configuration settings.
 */

const fs = require("fs");
const path = require("path");
const https = require("https");
const http = require("http");

const visionService = require("./vision-service");
const textTagging = require("./text-tagging");

// Configuration from environment
const ENABLE_AUTO_TAGGING = process.env.ENABLE_POST_AUTO_TAGGING === "true";
const ENABLE_TEXT_TAGGING = process.env.ENABLE_TEXT_AUTO_TAGGING !== "false";
const ENABLE_VISION_TAGGING = process.env.ENABLE_VISION_AUTO_TAGGING === "true";
const MAX_AUTO_TAGS = parseInt(process.env.POST_MAX_AUTO_TAGS) || 15;
const MIN_CONFIDENCE = parseFloat(process.env.POST_MIN_CONFIDENCE) || 0.5;

/**
 * Check if auto-tagging is enabled
 */
const isEnabled = () => ENABLE_AUTO_TAGGING;

/**
 * Check if text tagging is enabled
 */
const isTextEnabled = () => ENABLE_AUTO_TAGGING && ENABLE_TEXT_TAGGING;

/**
 * Check if vision tagging is enabled
 */
const isVisionEnabled = () => ENABLE_AUTO_TAGGING && ENABLE_VISION_TAGGING;

/**
 * Get configuration status
 */
const getConfig = () => ({
  enabled: isEnabled(),
  textEnabled: isTextEnabled(),
  visionEnabled: isVisionEnabled(),
  maxTags: MAX_AUTO_TAGS,
  minConfidence: MIN_CONFIDENCE,
});

/**
 * Download image from URL to temp file
 * @param {string} imageUrl - URL of the image
 * @returns {Promise<string|null>} - Path to temp file or null
 */
const downloadImageToTemp = async (imageUrl) => {
  return new Promise((resolve) => {
    const protocol = imageUrl.startsWith("https") ? https : http;
    const ext = path.extname(imageUrl) || ".jpg";
    const tempPath = path.join("/tmp", `post-vision-${Date.now()}${ext}`);
    const file = fs.createWriteStream(tempPath);

    const req = protocol.get(imageUrl, (res) => {
      if (res.statusCode !== 200) {
        fs.unlinkSync(tempPath);
        resolve(null);
        return;
      }
      res.pipe(file);
      file.on("finish", () => {
        file.close();
        resolve(tempPath);
      });
    });

    req.on("error", () => {
      fs.unlinkSync(tempPath);
      resolve(null);
    });

    req.setTimeout(10000, () => {
      req.destroy();
      fs.unlinkSync(tempPath);
      resolve(null);
    });
  });
};

/**
 * Generate vision tags from image URLs
 * @param {Array<string>} imageUrls - Array of image URLs
 * @param {Object} options - Tagging options
 * @returns {Promise<Array>} - Array of tag objects
 */
const generateVisionTagsFromUrls = async (imageUrls, options = {}) => {
  const allTags = [];
  const { maxTags = 10 } = options;

  for (const url of imageUrls) {
    try {
      const tempPath = await downloadImageToTemp(url);

      if (tempPath && fs.existsSync(tempPath)) {
        const result = await visionService.generateTags(tempPath, {
          maxTags: Math.ceil(maxTags / imageUrls.length),
          minConfidence: MIN_CONFIDENCE,
        });

        if (result.success && result.tags.length > 0) {
          allTags.push(
            ...result.tags.map((tag) => ({
              tag: tag.tag.toLowerCase().trim(),
              confidence: tag.confidence,
              autoGenerated: true,
              source: "vision",
            })),
          );
        }

        // Clean up temp file
        if (tempPath.startsWith("/tmp")) {
          fs.unlinkSync(tempPath);
        }
      }
    } catch (error) {
      console.error(
        `[PostTagging] Error processing image ${url}:`,
        error.message,
      );
    }
  }

  return allTags;
};

/**
 * Merge tags with deduplication and priority based on confidence
 * @param {Array} tags - Array of tag objects
 * @returns {Array} - Merged and sorted tags
 */
const mergeTags = (tags) => {
  const tagMap = new Map();

  tags.forEach((tag) => {
    const key = tag.tag.toLowerCase();
    const existing = tagMap.get(key);

    // Keep the tag with higher confidence
    if (!existing || (tag.confidence || 0) > (existing.confidence || 0)) {
      tagMap.set(key, {
        ...tag,
        tag: tag.tag.toLowerCase().trim(),
        confidence: tag.confidence || 0.5,
      });
    }
  });

  // Sort by confidence descending, then by tag name
  return Array.from(tagMap.values()).sort((a, b) => {
    if (b.confidence !== a.confidence) {
      return b.confidence - a.confidence;
    }
    return a.tag.localeCompare(b.tag);
  });
};

/**
 * Generate all tags for a post (images + text)
 * @param {Object} postData - Post data
 * @param {string} postData.title - Post title
 * @param {string} postData.content - Post content
 * @param {Array} postData.media - Post media array
 * @param {Object} options - Tagging options
 * @returns {Promise<Array>} - Array of tag objects
 */
const generatePostTags = async (postData, options = {}) => {
  const { title, content, media } = postData;
  const tags = [];

  // Check if auto-tagging is enabled
  if (!isEnabled()) {
    console.log("[PostTagging] Auto-tagging disabled in configuration");
    return [];
  }

  const maxTags = options.maxTags || MAX_AUTO_TAGS;

  // 1. Text-based tags from LLM
  if (isTextEnabled() && title && content) {
    try {
      console.log("[PostTagging] Generating text tags...");
      const textTags = await textTagging.generateTagsFromText(title, content, {
        maxTags: Math.ceil(maxTags * 0.6), // Text gets 60% of tag budget
        minConfidence: MIN_CONFIDENCE,
      });
      tags.push(...textTags);
      console.log(`[PostTagging] Generated ${textTags.length} text tags`);
    } catch (error) {
      console.error("[PostTagging] Text tagging error:", error.message);
    }
  }

  // 2. Vision tags from images
  if (isVisionEnabled() && media && media.length > 0) {
    const imageUrls = media
      .filter((m) => m.type === "image" && m.url)
      .map((m) => m.url);

    if (imageUrls.length > 0) {
      try {
        console.log(
          `[PostTagging] Generating vision tags for ${imageUrls.length} images...`,
        );
        const visionTags = await generateVisionTagsFromUrls(imageUrls, {
          maxTags: Math.ceil(maxTags * 0.4), // Vision gets 40% of tag budget
        });
        tags.push(...visionTags);
        console.log(`[PostTagging] Generated ${visionTags.length} vision tags`);
      } catch (error) {
        console.error("[PostTagging] Vision tagging error:", error.message);
      }
    }
  }

  // 3. Merge and deduplicate
  const mergedTags = mergeTags(tags);

  console.log(`[PostTagging] Total tags after merging: ${mergedTags.length}`);
  return mergedTags;
};

/**
 * Merge manual tags with AI-generated tags
 * Manual tags always take priority
 * @param {Array} manualTags - User-provided tags
 * @param {Array} aiTags - AI-generated tags
 * @returns {Array} - Combined and merged tags
 */
const mergeWithManualTags = (manualTags = [], aiTags = []) => {
  const tagMap = new Map();

  // Add manual tags first (highest priority)
  manualTags.forEach((tag) => {
    const key =
      typeof tag === "string" ? tag.toLowerCase() : tag.tag.toLowerCase();
    const tagValue = typeof tag === "string" ? tag : tag.tag;
    tagMap.set(key, {
      tag: tagValue,
      confidence: 1.0,
      autoGenerated: false,
      source: "manual",
    });
  });

  // Add AI tags if not already present
  aiTags.forEach((tag) => {
    const key = tag.tag.toLowerCase();
    if (!tagMap.has(key)) {
      tagMap.set(key, {
        ...tag,
        autoGenerated: true,
        confidence: tag.confidence || 0.5,
      });
    }
  });

  return Array.from(tagMap.values());
};

module.exports = {
  generatePostTags,
  generateVisionTagsFromUrls,
  mergeTags,
  mergeWithManualTags,
  isEnabled,
  isTextEnabled,
  isVisionEnabled,
  getConfig,
  downloadImageToTemp,
};
